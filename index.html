<!DOCTYPE html>
<html style="height: 100vh">
  <head>
    <title>idlecycles</title>
  </head>
  <body
    style="
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      display: flex;
      background: darkslateblue;
    "
  >
    <canvas
      id="canvas"
      style="width: 100%; height: 100%; position: fixed; pointer-events: none"
    ></canvas>
    <textarea
      id="code"
      spellcheck="false"
      style="
        width: 100%;
        z-index: 1;
        font-size: 24px;
        color: black;
        background: transparent;
        border: 0;
        outline: none;
        padding: 10px;
      "
    ></textarea>
    <button
      style="position: fixed; right: 0; bottom: 0; font-size: 30px"
      id="playButton"
    >
      play
    </button>
    <button
      style="
        display: none;
        position: fixed;
        right: 0;
        bottom: 0;
        font-size: 30px;
      "
      id="stopButton"
    >
      stop
    </button>
    <script>
      // lib
      // Hap<T> = { begin: number, end: number, value: T }
      // (a: number, b: number, callback: (cycle: number) => Hap[]) => Hap[]
      const collect = (a, b, callback) => {
        let events = [];
        while (a < b) {
          events = events.concat(callback(a));
          a++;
        }
        return events;
      };
      const collectWholes = (a, b, callback) =>
        collect(Math.floor(a), Math.ceil(b), callback);

      // Pattern<T> = (a: number, b: number) => Hap<T>[]

      // (T) => Pattern<T>
      const pure = (value) => (a, b) =>
        collect(a, b, (index) => [{ begin: index, end: index + 1, value }]);

      // MaybePattern<T> = T |Â Pattern<T>
      // MaybePattern<T> => Pattern<T>
      const reify = (value) => {
        if (typeof value !== "function") {
          return pure(value);
        }
        return value;
      };

      // (...MaybePattern<T>) => Pattern<T>
      const cat =
        (...values) =>
        (a, b) =>
          collectWholes(a, b, (index) => {
            let value = reify(values[index % values.length]);
            return value(index, index + 1);
          });

      // (...MaybePattern<T>) => Pattern<T>
      const stack =
        (...values) =>
        (a, b) =>
          collect(a, b, (index) => {
            return values.reduce((acc, v) => {
              let value = reify(v);
              let cycle = value(index, index + 1);
              return acc.concat(cycle);
            }, []);
          });

      // (number, MaybePattern<T>) => Pattern<T>
      const fast = (fac, pat) => (a, b) =>
        reify(pat)(a * fac, b * fac).map(({ begin, end, ...rest }) => ({
          begin: begin / fac,
          end: end / fac,
          ...rest,
        }));

      // (number, MaybePattern<T>) => Pattern<T>
      const slow = (fac, pat) => (a, b) =>
        reify(pat)(a / fac, b / fac).map(({ begin, end, ...rest }) => ({
          begin: begin * fac,
          end: end * fac,
          ...rest,
        }));

      // (...MaybePattern<T>) => Pattern<T>
      const seq = (...values) => fast(values.length, cat(...values));

      let joinLeft = (left, right, fn) => (a, b) => {
        const l = left(a, b);
        let bag = [];
        for (let i in l) {
          const { begin, end } = l[i];
          const r = right(begin, end);
          const value = fn(l[i].value, r[0].value);
          bag.push({ begin, end, value });
        }
        return bag;
      };
      let joinRight = (left, right, fn) => joinLeft(right, left, fn);

      // squeeze one cycle of right into each event of left
      let joinSqueezeRight = (left, right, fn) => (a, b) => {
        const l = left(a, b);
        let bag = [];
        for (let i in l) {
          const d = l[i].end - l[i].begin;
          const r = right(0, 1); // tbd find out which cycle belongs here..
          for (let j in r) {
            const value = fn(l[i].value, r[j].value);
            const begin = l[i].begin + r[j].begin * d;
            const end = l[i].begin + r[j].end * d;
            bag.push({ begin, end, value });
          }
        }
        return bag;
      };

      let joinSqueezeLeft = (left, right, fn) =>
        joinSqueezeRight(right, left, fn);

      // draw code

      const canvas = document.getElementById("canvas");
      canvas.width = canvas.clientWidth * window.devicePixelRatio;
      canvas.height = canvas.clientHeight * window.devicePixelRatio;

      const ctx = canvas.getContext("2d");
      function draw(pat, cycles = 4) {
        const { width, height } = ctx.canvas;
        ctx.fillStyle = "lightgray";
        ctx.fillRect(0, 0, width, height);
        const x = (normalized) => normalized * width;
        const y = (normalized) => normalized * height;
        pat(0, cycles).forEach(({ begin, end, value }) => {
          const [nx, nw] = [begin, end - begin];
          const [ny, nh] = [Math.floor(begin) / cycles, height / cycles];
          ctx.fillStyle = value;
          const rect = [x(nx) % width, y(ny), x(nw), nh];
          ctx.fillRect(...rect);
        });
      }

      // tool code
      console.log(
        `Welcome to idlecycles.. this is still wip.
      Read https://github.com/felixroos/idlecycles to find out more!
        `
      );
      let ac;
      document.addEventListener("click", function initAudio() {
        ac = new AudioContext();
        ac.resume();
        document.removeEventListener("click", initAudio);
      });

      // control
      let worklet,
        hz = 44100;
      const stop = async () => {
        //
        stopButton.style.display = "none";
        playButton.style.display = "block";
      };

      let hash2code = (hash) => decodeURIComponent(atob(hash));
      let code2hash = (code) => btoa(encodeURIComponent(code));

      const update = async (code) => {
        console.log("go", code);
        /* ac = ac || new AudioContext();
        await ac.resume();
        stop(); */
        console.log("code", code);
        const pat = new Function(`return ${code}`)();
        console.log("pat", pat);
        draw(pat, 4);

        console.log("code", code);
        window.location.hash = "#" + code2hash(code);
        stopButton.style.display = "block";
        playButton.style.display = "none";
      };

      // ui
      const input = document.getElementById("code");
      const playButton = document.getElementById("playButton");
      const stopButton = document.getElementById("stopButton");
      let urlCode = window.location.hash.slice(1);
      if (urlCode) {
        urlCode = hash2code(urlCode);
        console.log("loaded code from url!");
      }
      const initialCode = urlCode || `fast(4, seq('cyan','magenta','yellow'))`;
      input.value = initialCode;
      update(initialCode);

      input.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
          update(input.value);
        } else if ((e.ctrlKey || e.altKey) && e.code === "Period") {
          stop();
          e.preventDefault();
        }
      });

      playButton.addEventListener("click", () => update(input.value));
      stopButton.addEventListener("click", () => stop());
    </script>
  </body>
</html>
