<!DOCTYPE html>
<html style="height: 100vh">
  <head>
    <title>idlecycles</title>
  </head>
  <body
    style="
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      display: flex;
      background: darkslateblue;
    "
  >
    <canvas
      id="canvas"
      style="width: 100%; height: 100%; position: fixed; pointer-events: none"
    ></canvas>
    <textarea
      id="code"
      spellcheck="false"
      style="
        width: 100%;
        z-index: 1;
        font-size: 24px;
        color: black;
        background: transparent;
        border: 0;
        outline: none;
        padding: 10px;
      "
    ></textarea>
    <script>
      // lib
      class Pattern {
        constructor(query) {
          this.query = query;
        }
      }
      const collect = (callback) =>
        new Pattern((a, b) => {
          let events = [];
          a = Math.floor(a);
          b = Math.ceil(b);
          while (a < b) {
            events = events.concat(callback(a));
            a++;
          }
          return events;
        });

      const pure = (value) =>
        collect((cycle) => [{ begin: cycle, end: cycle + 1, value }]);

      const reify = (value) => {
        if (value instanceof Pattern) {
          return value;
        }
        return pure(value);
      };

      let joinLeft = (fn, left, right) => (a, b) => {
        const l = left(a, b);
        let bag = [];
        for (let i in l) {
          const { begin, end } = l[i];
          const r = right(begin, end);
          const value = fn(l[i].value, r[0].value);
          bag.push({ begin, end, value });
        }
        return bag;
      };

      // squeeze one cycle of right into each event of left
      let joinSqueezeRight = (left, right, fn) => (a, b) => {
        const l = left(a, b);
        let bag = [];
        for (let i in l) {
          const d = l[i].end - l[i].begin;
          const r = right(0, 1); // tbd find out which cycle belongs here..
          for (let j in r) {
            const value = fn(l[i].value, r[j].value);
            const begin = l[i].begin + r[j].begin * d;
            const end = l[i].begin + r[j].end * d;
            bag.push({ begin, end, value });
          }
        }
        return bag;
      };

      let joinSqueezeLeft = (left, right, fn) =>
        joinSqueezeRight(right, left, fn);

      let register = (name, fn) => {
        const q = (...args) => {
          return new Pattern((a, b) => {
            if (args[0] instanceof Pattern) {
              let haps = [];
              const src = reify(args[args.length - 1]).query(a, b);
              for (let j in src) {
                const hap = src[j];
                const match = args[0].query(hap.begin, hap.end)[0].value;
                const _args = [match, ...args.slice(1)];
                const subhaps = fn(..._args).query(hap.begin, hap.end);
                /*  console.log(
                  name,
                  match,
                  ":",
                  hap.begin,
                  hap.end,
                  "during",
                  hap.value,
                  "=",
                  subhaps
                ); */
                haps = haps.concat(subhaps);
              }
              return haps;
            }
            return fn(...args).query(a, b);
          });
        };
        // const q = fn;
        Pattern.prototype[name] = function (...args) {
          return q(...args, this);
        };
        return q;
      };

      // lib
      const cat = (...values) =>
        collect((cycle) => {
          let pat = reify(values[cycle % values.length]);
          return pat.query(cycle, cycle + 1);
        });

      const stack = (...values) =>
        collect((cycle) => {
          return values.reduce((acc, v) => {
            let pat = reify(v);
            return acc.concat(pat.query(cycle, cycle + 1));
          }, []);
        });

      const fast = register(
        "fast",
        (fac, pat) =>
          new Pattern((a, b) =>
            pat.query(a * fac, b * fac).map(({ begin, end, ...rest }) => ({
              begin: begin / fac,
              end: end / fac,
              ...rest,
            }))
          )
      );
      const slow = register("slow", (fac, pat) => fast(1 / fac, pat));

      const seq = (...values) => fast(values.length, cat(...values));
      // draw code

      const canvas = document.getElementById("canvas");
      canvas.width = canvas.clientWidth * window.devicePixelRatio;
      canvas.height = canvas.clientHeight * window.devicePixelRatio;

      const ctx = canvas.getContext("2d");
      function draw(pat, cycles = 16) {
        const { width, height } = ctx.canvas;
        ctx.fillStyle = "lightgray";
        ctx.fillRect(0, 0, width, height);
        const x = (normalized) => normalized * width;
        const y = (normalized) => normalized * height;
        ctx.strokeStyle = "black";
        ctx.lineWidth = 6;
        const haps = pat.query(0, cycles);
        haps.forEach(({ begin, end, value }) => {
          const [nx, nw] = [begin, end - begin];
          const [ny, nh] = [Math.floor(begin) / cycles, height / cycles];
          ctx.fillStyle = value;
          const rect = [x(nx) % width, y(ny), x(nw), nh];
          ctx.strokeRect(...rect);
          ctx.fillRect(...rect);
        });
      }

      // tool code
      console.log(
        `Welcome to idlecycles.. this is still wip.
      Read https://github.com/felixroos/idlecycles to find out more!
        `
      );
      let ac;
      document.addEventListener("click", function initAudio() {
        ac = new AudioContext();
        ac.resume();
        document.removeEventListener("click", initAudio);
      });

      // control
      let worklet,
        hz = 44100;
      const stop = async () => {
        //
      };

      let hash2code = (hash) => decodeURIComponent(atob(hash));
      let code2hash = (code) => btoa(encodeURIComponent(code));

      const update = async (code) => {
        console.log("update:");
        console.log(code);
        /* ac = ac || new AudioContext();
        await ac.resume();
        stop(); */
        const pat = new Function(`return ${code}`)();
        draw(pat);

        window.location.hash = "#" + code2hash(code);
      };

      // ui
      const input = document.getElementById("code");
      let urlCode = window.location.hash.slice(1);
      if (urlCode) {
        urlCode = hash2code(urlCode);
        console.log("loaded code from url!");
      }
      const initialCode = urlCode || `fast(4, seq('cyan','magenta','yellow'))`;
      input.value = initialCode;
      update(initialCode);

      input.addEventListener("keydown", (e) => {
        if ((e.ctrlKey || e.altKey) && e.key === "Enter") {
          update(input.value);
        } else if ((e.ctrlKey || e.altKey) && e.code === "Period") {
          stop();
          e.preventDefault();
        }
      });
    </script>
  </body>
</html>
